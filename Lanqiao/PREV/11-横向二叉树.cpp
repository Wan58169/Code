//问题描述
//二叉树可以用于排序。其原理很简单：对于一个排序二叉树添加新节点时，先与根节点比较，若小则交给左子树继续处理，否则交给右子树。
//
//当遇到空子树时，则把该节点放入那个位置。
//
//比如，10 8 5 7 12 4 的输入顺序，应该建成二叉树如下图所示，其中.表示空白。
//
//...|-12
//10-|
//...|-8-|
//.......|...|-7
//.......|-5-|
//...........|-4
//本题目要求：根据已知的数字，建立排序二叉树，并在标准输出中横向打印该二叉树。
//
//输入格式
//输入数据为一行空格分开的N个整数。 N<100，每个数字不超过10000。
//
//输入数据中没有重复的数字。
//
//输出格式
//输出该排序二叉树的横向表示。为了便于评卷程序比对空格的数目，请把空格用句点代替：
//
//样例输入1
//10 5 20
//样例输出1
//...|-20
//10-|
//...|-5
//样例输入2
//5 10 20 8 4 7
//样例输出2
//.......|-20
//..|-10-|
//..|....|-8-|
//..|........|-7
//5-|
//..|-4
#include<iostream>
#include<algorithm>
using namespace std;

int a[101];		//存放节点 
int b[101];		//存放排序后的节点
 
bool cmp(int a,int b)
{
	return a>b;
}
int main()
{
	freopen("11.txt","r",stdin);
	int t;
	int aLen=0,bLen=0;
	while(cin >> t) 
	{
		a[aLen++] = t;	
		b[bLen++] = t;
	}
	sort(b,b+bLen,cmp);
	char map[aLen][]
//	for(int i=0; i<bLen; i++)
//	{
//		cout << b[i] << " ";
//	}
//	cout << " " << endl;
	return 0;
}
